package com.example.fortune_whell_v3.viewmodel

import android.Manifest
import kotlinx.coroutines.withTimeoutOrNull
import kotlinx.coroutines.flow.first
import android.app.Application
import android.bluetooth.*
import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import android.util.Log
import androidx.core.content.ContextCompat
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import java.util.*

class BLEViewModel(application: Application) : AndroidViewModel(application) {
    private val context = application.applicationContext
    private var gatt: BluetoothGatt? = null

    private val bluetoothAdapter: BluetoothAdapter? =
        (context.getSystemService(Context.BLUETOOTH_SERVICE) as? BluetoothManager)?.adapter

    // üîπ Estados de conex√£o BLE
    private val _connectionState = MutableStateFlow("Desconectado")
    val connectionState: StateFlow<String> = _connectionState.asStateFlow()

    private val _receivedMessage = MutableStateFlow<BleMessage>(BleMessage.Unknown(""))
    val receivedMessage: StateFlow<BleMessage> = _receivedMessage.asStateFlow()

    // üîπ UUIDs para comunica√ß√£o BLE
    private val SERVICE_UUID = UUID.fromString("19B10000-E8F2-537E-4F6C-D104768A1214")
    private val CHARACTERISTIC_UUID = UUID.fromString("19B10001-E8F2-537E-4F6C-D104768A1214")

    // üîπ Conectar ao dispositivo j√° pareado pelo nRF Connect
    fun connectToExistingDevice(macAddress: String) {
        viewModelScope.launch(Dispatchers.IO) {
            Log.d("BLEViewModel", "üöÄ A tentar conectar ao MAC: $macAddress") // ‚Üê AQUI
            if (!hasBluetoothPermission()) {
                Log.e("BLEViewModel", "‚ùå Permiss√£o BLUETOOTH_CONNECT n√£o concedida!")
                _connectionState.value = "Erro: Permiss√£o negada"
                return@launch
            }

            bluetoothAdapter?.let { adapter ->
                try {
                    val device = adapter.getRemoteDevice(macAddress)
                    _connectionState.value = "Conectando..."

                    gatt = device.connectGatt(context, false, gattCallback, BluetoothDevice.TRANSPORT_LE)

                } catch (e: SecurityException) {
                    _connectionState.value = "Erro de permiss√£o Bluetooth"
                    Log.e("BLEViewModel", "‚ùå Erro ao conectar ao BLE", e)
                } catch (e: IllegalArgumentException) {
                    _connectionState.value = "Erro: Dispositivo inv√°lido"
                    Log.e("BLEViewModel", "‚ùå MAC Address inv√°lido!", e)
                }
            } ?: run {
                _connectionState.value = "Bluetooth n√£o suportado"
            }
        }
    }
    // üîπ M√©todo para enviar dados ap√≥s a conex√£o
    fun sendData(data: String) {
        gatt?.let { gatt ->
            val service = gatt.getService(SERVICE_UUID)
            val characteristic = service?.getCharacteristic(CHARACTERISTIC_UUID)

            if (characteristic == null) {
                Log.e("BLEViewModel", "‚ùå Caracter√≠stica BLE n√£o encontrada! Verifica os UUIDs e a descoberta de servi√ßos.")
                return
            }

            if ((characteristic.properties and BluetoothGattCharacteristic.PROPERTY_WRITE) == 0) {
                Log.e("BLEViewModel", "‚ùå Caracter√≠stica n√£o suporta escrita!")
                return
            }

            val dataToSend = data.toByteArray(Charsets.UTF_8)

            if (ContextCompat.checkSelfPermission(context, Manifest.permission.BLUETOOTH_CONNECT) != PackageManager.PERMISSION_GRANTED) {
                Log.e("BLEViewModel", "‚ö†Ô∏è Permiss√£o BLUETOOTH_CONNECT n√£o concedida!")
                return
            }

            try {
                gatt.writeCharacteristic(characteristic, dataToSend, BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT)
                Log.d("BLEViewModel", "üì° Dados enviados: $data")
            } catch (e: SecurityException) {
                Log.e("BLEViewModel", "‚ùå Erro de permiss√£o ao escrever caracter√≠stica BLE", e)
            } catch (e: Exception) {
                Log.e("BLEViewModel", "‚ùå Erro inesperado ao enviar dados", e)
            }
        } ?: Log.e("BLEViewModel", "‚ùå GATT √© null! Dispositivo pode n√£o estar conectado.")
    }

    // üîπ Ativar notifica√ß√µes para receber dados do dispositivo BLE
    private fun enableNotifications(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic) {
        try {
            gatt.setCharacteristicNotification(characteristic, true)

            val descriptor = characteristic.getDescriptor(UUID.fromString("00002902-0000-1000-8000-00805f9b34fb"))

            gatt.writeDescriptor(descriptor, BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE)
            Log.d("BLEViewModel", "‚úÖ Notifica√ß√µes habilitadas para ${characteristic.uuid}")

        } catch (e: SecurityException) {
            Log.e("BLEViewModel", "Erro ao ativar notifica√ß√µes BLE", e)
        } catch (e: IllegalArgumentException) {
            Log.e("BLEViewModel", "Erro: Descriptor inv√°lido!", e)
        }
    }

    private fun hasBluetoothPermission(): Boolean {
        return ContextCompat.checkSelfPermission(context, Manifest.permission.BLUETOOTH_CONNECT) == PackageManager.PERMISSION_GRANTED
    }

    private val gattCallback = object : BluetoothGattCallback() {
        override fun onConnectionStateChange(gatt: BluetoothGatt?, status: Int, newState: Int) {
            when (newState) {
                BluetoothProfile.STATE_CONNECTED -> {
                    _connectionState.value = "Conectado"
                    Log.d("BLEViewModel", "‚úÖ Conectado! Descobrindo servi√ßos...")

                    if (hasBluetoothPermission()) {
                        try {
                            gatt?.discoverServices()
                        } catch (e: SecurityException) {
                            Log.e("BLEViewModel", "Erro de permiss√£o ao descobrir servi√ßos", e)
                        }
                    }
                }
                BluetoothProfile.STATE_DISCONNECTED -> {
                    _connectionState.value = "Desconectado"
                    Log.d("BLEViewModel", "‚ùå Desconectado.")
                }
            }
        }

        override fun onServicesDiscovered(gatt: BluetoothGatt?, status: Int) {
            if (status == BluetoothGatt.GATT_SUCCESS) {
                Log.d("BLEViewModel", "üîç Servi√ßos descobertos:")
                gatt?.services?.forEach { service ->
                    Log.d("BLEViewModel", "  üß© Servi√ßo: ${service.uuid}")
                    service.characteristics.forEach { char ->
                        Log.d("BLEViewModel", "     ‚Ü≥ Caracter√≠stica: ${char.uuid} - propriedades: ${char.properties}")
                    }
                }

                val service = gatt?.getService(SERVICE_UUID)
                val characteristic = service?.getCharacteristic(CHARACTERISTIC_UUID)

                if (characteristic != null) {
                    Log.d("BLEViewModel", "‚úÖ Caracter√≠stica encontrada! Ativando notifica√ß√µes...")
                    enableNotifications(gatt, characteristic)
                } else {
                    Log.e("BLEViewModel", "‚ùå Caracter√≠stica BLE n√£o encontrada! Verifica os UUIDs e a descoberta de servi√ßos.")
                }
            } else {
                Log.e("BLEViewModel", "‚ö†Ô∏è Falha ao descobrir servi√ßos BLE!")
            }
        }



        @Suppress("DEPRECATION")
        override fun onCharacteristicChanged(
            gatt: BluetoothGatt?,
            characteristic: BluetoothGattCharacteristic?
        ) {
            val raw = characteristic?.value?.toString(Charsets.UTF_8)?.trim() ?: return
            val parsed = parseBleMessage(raw)

            Log.d("BLEViewModel", "üì© Mensagem interpretada: $parsed")

            viewModelScope.launch {
                _receivedMessage.emit(parsed)
            }
        }
    }

    /** üîπ **Apenas usa o GATT de um dispositivo j√° conectado pelo nRF Connect** */
    fun useExistingGattConnection(device: BluetoothDevice) {
        viewModelScope.launch(Dispatchers.IO) {
            try {
                if (!hasBluetoothPermission()) {
                    Log.e("BLEViewModel", "‚ö†Ô∏è Permiss√£o BLUETOOTH_CONNECT n√£o concedida!")
                    return@launch
                }

                gatt = device.connectGatt(context, false, gattCallback, BluetoothDevice.TRANSPORT_LE)
                Log.d("BLEViewModel", "‚úÖ Usando conex√£o BLE existente.")
            } catch (e: SecurityException) {
                Log.e("BLEViewModel", "Erro de permiss√£o ao usar conex√£o existente.", e)
            }
        }
    }

    fun updateConnectionState() {
        val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager

        try {
            // Apenas verifica permiss√£o no Android 12+
            if (ContextCompat.checkSelfPermission(context, Manifest.permission.BLUETOOTH_CONNECT) != PackageManager.PERMISSION_GRANTED) {
                _connectionState.value = "Permiss√£o negada"
                return
            }

            val connectedDevices = bluetoothManager.getConnectedDevices(BluetoothProfile.GATT)

            if (connectedDevices.isNotEmpty()) {
                val device = connectedDevices[0]
                _connectionState.value = "Conectado"

                gatt = device.connectGatt(context, false, gattCallback, BluetoothDevice.TRANSPORT_LE)
                gatt?.discoverServices()
            } else {
                _connectionState.value = "Desconectado"
            }

        } catch (e: SecurityException) {
            Log.e("Bluetooth", "‚ùå Permiss√£o de Bluetooth negada em tempo de execu√ß√£o", e)
            _connectionState.value = "Permiss√£o negada"
        } catch (e: Exception) {
            Log.e("Bluetooth", "‚ùå Erro ao verificar dispositivos conectados", e)
            _connectionState.value = "Erro ao conectar"
        }
    }

    sealed class BleMessage {
        object Ok : BleMessage()
        object Fim : BleMessage()
        object Erro : BleMessage()
        object SemPapel : BleMessage()
        data class Unknown(val raw: String) : BleMessage()
    }

    fun parseBleMessage(raw: String): BleMessage {
        val trimmed = raw.trim()
        val upper = trimmed.uppercase()

        return when (upper) {
            "OK" -> {
                Log.d("BLERecebido", "üßæ BLE recebido: '$trimmed' (${trimmed.length} chars)")
                BleMessage.Ok
            }

            "TAMPA ABERTA" ->{
                Log.d("BLERecebido", "üßæ BLE recebido: '$trimmed' (${trimmed.length} chars)")
                BleMessage.Fim
            }

            "ERRO" ->{
                Log.d("BLERecebido", "üßæ BLE recebido: '$trimmed' (${trimmed.length} chars)")
                BleMessage.Erro
            }

            "SEM_PAPEL" ->{
                Log.d("BLERecebido", "üßæ BLE recebido: '$trimmed' (${trimmed.length} chars)")
                BleMessage.SemPapel
            }

            else -> {
                Log.w("BLE", "üî∏ Ignorado: '$trimmed' (${trimmed.length} chars)")
                BleMessage.Unknown(trimmed)
            }
        }
    }

    suspend fun awaitResposta(timeout: Long = 5000L): String? {
        return withTimeoutOrNull(timeout) {
            receivedMessage.first {
                when (it) {
                    is BleMessage.Ok,
                    is BleMessage.Fim,
                    is BleMessage.Erro,
                    is BleMessage.SemPapel -> true

                    else -> false
                }
            }.let { msg ->
                when (msg) {
                    is BleMessage.Ok -> "OK"
                    is BleMessage.Fim -> "FIM"
                    is BleMessage.Erro -> "ERRO"
                    is BleMessage.SemPapel -> "SEM_PAPEL"
                    else -> null
                }
            }
        }
    }

}
